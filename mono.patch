diff --git a/eglib/src/glib.h b/eglib/src/glib.h
index 619a071..cee8530 100644
--- a/eglib/src/glib.h
+++ b/eglib/src/glib.h
@@ -494,7 +494,9 @@ typedef enum {
 	G_LOG_LEVEL_MASK              = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
 } GLogLevelFlags;
 
-void           g_print                (const gchar *format, ...);
+//void           g_print                (const gchar *format, ...);
+#define LOG_TAG "Mono"
+#define g_print LOGI
 GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);
 GLogLevelFlags g_log_set_fatal_mask   (const gchar *log_domain, GLogLevelFlags fatal_mask);
 void           g_logv                 (const gchar *log_domain, GLogLevelFlags log_level, const gchar *format, va_list args);
diff --git a/libgc/os_dep.c b/libgc/os_dep.c
index 83b166c..8089352 100644
--- a/libgc/os_dep.c
+++ b/libgc/os_dep.c
@@ -336,13 +336,6 @@ char *GC_parse_map_entry(char *buf_ptr, word *start, word *end,
   {
     extern ptr_t GC_find_limit();
 
-	if (GC_no_dls)
-		/* 
-		 * Not needed, avoids the SIGSEGV caused by GC_find_limit which
-		 * complicates debugging.
-		 */
-		return;
-
 #   ifdef LINUX
       /* Try the easy approaches first:	*/
       if ((ptr_t)__data_start != 0) {
diff --git a/mono/io-layer/collection.c b/mono/io-layer/collection.c
index 2da5505..569563a 100644
--- a/mono/io-layer/collection.c
+++ b/mono/io-layer/collection.c
@@ -45,12 +45,7 @@ static gpointer collection_thread (gpointer unused G_GNUC_UNUSED)
 
 	pthread_exit (NULL);
 
-#ifndef __GNUC__
-	/* Even though we tell gcc that this function doesn't return,
-	 * other compilers won't see that.
-	 */
 	return(NULL);
-#endif
 }
 
 void _wapi_collection_init (void)
diff --git a/mono/io-layer/shared.c b/mono/io-layer/shared.c
index 5f71ac4..7260ca7 100644
--- a/mono/io-layer/shared.c
+++ b/mono/io-layer/shared.c
@@ -19,7 +19,11 @@
 #include <errno.h>
 #include <string.h>
 #include <sys/ipc.h>
+#ifdef HAVE_SYS_SEM
 #include <sys/sem.h>
+#else
+#define DISABLE_SHARED_HANDLES
+#endif
 
 #ifdef HAVE_SYS_UTSNAME_H
 #include <sys/utsname.h>
@@ -363,6 +367,7 @@ gpointer _wapi_shm_attach (_wapi_shm_t type)
 	return(shm_seg);
 }
 
+#ifdef HAVE_SYS_SEM
 static void shm_semaphores_init (void)
 {
 	key_t key;
@@ -518,6 +523,7 @@ again:
 	else
 		munmap (tmp_shared, sizeof(struct _WapiHandleSharedLayout));
 }
+#endif
 
 static mono_mutex_t noshm_sems[_WAPI_SHARED_SEM_COUNT];
 
@@ -530,6 +536,7 @@ static void noshm_semaphores_init (void)
 	}
 }
 
+#ifdef HAVE_SYS_SEM
 static void shm_semaphores_remove (void)
 {
 	int thr_ret;
@@ -576,12 +583,14 @@ static void shm_semaphores_remove (void)
 		_wapi_shm_sem_unlock (_WAPI_SHARED_SEM_PROCESS_COUNT_LOCK);
 	}
 }
+#endif
 
 static void noshm_semaphores_remove (void)
 {
 	/* No need to do anything */
 }
 
+#ifdef HAVE_SYS_SEM
 static int shm_sem_lock (int sem)
 {
 	struct sembuf ops;
@@ -627,6 +636,7 @@ static int shm_sem_lock (int sem)
 	
 	return(ret);
 }
+#endif
 
 static int noshm_sem_lock (int sem)
 {
@@ -641,6 +651,7 @@ static int noshm_sem_lock (int sem)
 	return(ret);
 }
 
+#ifdef HAVE_SYS_SEM
 static int shm_sem_trylock (int sem)
 {
 	struct sembuf ops;
@@ -691,6 +702,7 @@ static int shm_sem_trylock (int sem)
 	
 	return(ret);
 }
+#endif
 
 static int noshm_sem_trylock (int sem)
 {
@@ -705,6 +717,7 @@ static int noshm_sem_trylock (int sem)
 	return(ret);
 }
 
+#ifdef HAVE_SYS_SEM
 static int shm_sem_unlock (int sem)
 {
 	struct sembuf ops;
@@ -751,6 +764,7 @@ static int shm_sem_unlock (int sem)
 
 	return(ret);
 }
+#endif
 
 static int noshm_sem_unlock (int sem)
 {
@@ -767,45 +781,65 @@ static int noshm_sem_unlock (int sem)
 
 void _wapi_shm_semaphores_init (void)
 {
+#ifndef HAVE_SYS_SEM
+	noshm_semaphores_init ();
+#else
 	if (check_disabled ()) {
 		noshm_semaphores_init ();
 	} else {
 		shm_semaphores_init ();
 	}
+#endif
 }
 
 void _wapi_shm_semaphores_remove (void)
 {
+#ifndef HAVE_SYS_SEM
+	noshm_semaphores_remove ();
+#else
 	if (_wapi_shm_disabled) {
 		noshm_semaphores_remove ();
 	} else {
 		shm_semaphores_remove ();
 	}
+#endif
 }
 
 int _wapi_shm_sem_lock (int sem)
 {
+#ifndef HAVE_SYS_SEM
+	return(noshm_sem_lock (sem));
+#else
 	if (_wapi_shm_disabled) {
 		return(noshm_sem_lock (sem));
 	} else {
 		return(shm_sem_lock (sem));
 	}
+#endif
 }
 
 int _wapi_shm_sem_trylock (int sem)
 {
+#ifndef HAVE_SYS_SEM
+	return(noshm_sem_trylock (sem));
+#else
 	if (_wapi_shm_disabled) {
 		return(noshm_sem_trylock (sem));
 	} else {
 		return(shm_sem_trylock (sem));
 	}
+#endif
 }
 
 int _wapi_shm_sem_unlock (int sem)
 {
+#ifndef HAVE_SYS_SEM
+	return(noshm_sem_unlock (sem));
+#else
 	if (_wapi_shm_disabled) {
 		return(noshm_sem_unlock (sem));
 	} else {
 		return(shm_sem_unlock (sem));
 	}
+#endif
 }
diff --git a/mono/mini/mini-arm.c b/mono/mini/mini-arm.c
index fd5f7b5..085969d 100644
--- a/mono/mini/mini-arm.c
+++ b/mono/mini/mini-arm.c
@@ -653,7 +653,7 @@ mono_arch_flush_icache (guint8 *code, gint size)
 		"svc     0x00000000\n"
 		:
 		:	"r" (code), "r" (code + size), "r" (syscall)
-		:	"r0", "r1", "r7"
+		:	"r0", "r1", "r7", "r2"
 		);
 #else
 	__asm __volatile ("mov r0, %0\n"
diff --git a/mono/mini/mini.c b/mono/mini/mini.c
index 2e84625..763c2c4 100644
--- a/mono/mini/mini.c
+++ b/mono/mini/mini.c
@@ -4687,6 +4687,8 @@ mini_free_jit_domain_info (MonoDomain *domain)
 	domain->runtime_info = NULL;
 }
 
+void register_icalls ();
+
 MonoDomain *
 mini_init (const char *filename, const char *runtime_version)
 {
@@ -4826,6 +4828,7 @@ mini_init (const char *filename, const char *runtime_version)
 	mono_add_internal_call ("Mono.Runtime::mono_runtime_install_handlers", 
 				mono_runtime_install_handlers);
 
+	register_icalls ();
 
 	create_helper_signature ();
 
